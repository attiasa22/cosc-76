# PA6 - Hidden Markov Model
## Report
### by Ariel Attias for COSC 76 21F



**(a) Description: How do your implemented algorithms work? What design decisions did you make? How you laid out the problems? In particular, for this specific assignment, explain your model precisely, and explain exactly how you compute each new distribution of possible states.**

My implemented algorithms work by first splitting up the problem and the solution into seperate classes, and uses the Maze class from earlier problem sets to set up the maze the Hidden Markov Model will be analyzing.
 
A. The Maze Problem class stores its states (or floors), their initial probabilities, sets a random initial state, and the sensor probabilities, and keeps track of the filtering output such as each distribution calculated, as well as the actual movements of the robot.

Given these values, the class also has functions to set up the relevant matrices, the random start position, and also has the functions to set the random next state, as well as a function which displays the solution.

In order to maintain the idea that the robot does not know the true color of the floor, the function that calculates the robot's movement , `get_new_state`, also calculates the sensor's imperfect reading and only returns the reading. Therefore the true locations and sensor readings are never returned, and only stored in the object's solution variables for display.

B. The Markov Solver class does all the work calculating each events distribution. The HMM filtering is done with the matrix method discussed in the AI textbook. Numpy functionality is greatly taken advantage here to built the transition, observation and filtering matrices.

Each floor tile is converted to a state (numbered 0 through s for s states) the HMM model will calculate a distribution for. F_t is initialized as an even distribution amongst all the states, as the inititial robot positioning is random.

Th transition matrix T is built by going through all the states and determining which other states are neighbors. If a state i can be reached from state j, T_ij has value 0.25, representing the random event it came from there. Since the robot follows pacman rules, if a state is unreachable from a coordinate which is not a state but rather a wall or outside the maze, Tii is incremented by 0.25, since this represents an action where the initial and final state of an action are the same.

For each time the filtering algorithm is used, an observation matrix is generated. From the sensor reading obtained from the problem class's `get_new_state`, each state is assigned a probability that the sensor reading came from that floor. In this case the same color gives a value of 0.88, otherwise it is 0.12. These values are then diagonalized into an s x s, matrix, for s states. the current distribution matrix, f_t, is then multiplied by the transpose of the transition matrix and the observation matrix and then passed to reference f_t, as the filtering algorithm for f_1:t+1 depends on f_1:t


### Extra Credit
The Viterbi Algorithm was implemented for extra credit. It takes advantage of matrix multiplication as well due to the simplicity of implementation yielded by the numpy. For this algorithm, the observation space as well as the emission matrix is required. The emission matrix is a K x N matrix where K is the number of states and N is the number of possible observation events (or number of colors).Each cell E[i][j] is the probability of observing j from state i. The Viterbi Algorithm is implemented with a dynamic programming approach, taking the argmax for each state after performing some filtering, to find the a posteriori most likely state given a sequence of observations. This is why the Viterbi is performed after the filtering call, in order to have a set of observations to pass.




**b) Evaluation: Do your implemented algorithms actually work? How well? If it doesnâ€™t work, can you tell why not? What partial successes did you have that deserve partial credit? Include a comparison of running time results using different heuristics and inference.**

The implemented algorithms, both filtering as well as Viterbi, actually work. The values generated by the algorithm for a 4 x 4 matrix, as well as for the other included mazes, make sense. A sample run is included below:
